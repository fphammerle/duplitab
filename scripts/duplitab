#!/usr/bin/env python3
# PYTHON_ARGCOMPLETE_OK

import hashlib
import os
import shlex
import subprocess
import tempfile
import time
import urllib.parse
import yaml

def command_join(args):
    return ' '.join([shlex.quote(a) for a in args])

def sshfs_mount(url, path):
    """
    > Duplicity uses the URL format [...].  The generic format for a URL is:
    >     scheme://[user[:password]@]host[:port]/[/]path
    > [...]
    > In protocols that support it, the path may be preceded by a single slash, '/path', to
    > represent a relative path to the target home directory, or preceded by a double slash,
    > '//path', to represent an absolute filesystem path.
    """
    url_attr = urllib.parse.urlparse(url)
    assert url_attr.scheme in ['sftp']
    mount_command = [
        'sshfs',
        '{}:{}'.format(url_attr.netloc, url_attr.path[1:]),
        path,
        ]
    print('+ {}'.format(command_join(mount_command)))
    subprocess.check_call(mount_command)

def sshfs_unmount(path, retry_delay_seconds = 1.0, retry_count = 2):
    unmount_command = [
        'fusermount',
        '-u',
        path,
        ]
    print('+ {}'.format(command_join(unmount_command)))
    try:
        subprocess.check_call(unmount_command)
    except subprocess.CalledProcessError as ex:
        if retry_count > 0:
            time.sleep(retry_delay_seconds)
            sshfs_unmount(
                    path = path,
                    retry_delay_seconds = retry_delay_seconds,
                    retry_count = retry_count - 1,
                    )
        else:
            raise ex

def backup(config, no_print_config, no_print_statistics, tab_dry):

    for backup in config:

        if not no_print_config:
            print(yaml.dump({"backup": backup}, default_flow_style = False))

        backup_command = ['duplicity']

        # encryption
        try:
            encryption = backup['encryption']
        except KeyError:
            encryption = True
        if 'encryption' in backup and not backup['encryption']:
            backup_command += ['--no-encryption']
        else:
            if 'encrypt_key' in backup:
                backup_command += ['--encrypt-key', backup['encrypt_key']]

        # determine source
        try:
            source_type = backup['source_type']
        except KeyError:
            source_type = 'local'
        source_mount_path = None
        try:
            if source_type == 'local':
                local_source_path = backup['source_path']
            elif source_type == 'sshfs':
                source_mount_path = tempfile.mkdtemp(prefix = 'duplitab-source-sshfs-')
                sshfs_mount(
                    url = 'sftp://{}/{}'.format(backup['source_host'], backup['source_path']),
                    path = source_mount_path,
                    )
                local_source_path = source_mount_path
                backup_command.append('--allow-source-mismatch')
            else:
                raise Exception("unsupported source type '{}'".format(source_type))

            # selectors
            try:
                selectors = backup['selectors']
            except KeyError:
                selectors = []
            for selector in selectors:
                if selector['option'] in ['include', 'exclude']:
                    shell_pattern = selector['shell_pattern']
                    if shell_pattern.startswith(backup['source_path']):
                        shell_pattern = shell_pattern.replace(
                                backup['source_path'],
                                local_source_path,
                                1,
                                )
                    backup_command += ['--{}'.format(selector['option']), shell_pattern]
                else:
                    raise Exception("unsupported selector option '{}'".format(selector['option']))

            # statistics
            if no_print_statistics:
                backup_command.append('--no-print-statistics')

            # source path
            backup_command.append(local_source_path)

            # target
            target_mount_path = None
            try:
                if 'target_via_sshfs' in backup and backup['target_via_sshfs']:
                    target_mount_path = tempfile.mkdtemp(prefix = 'duplitab-target-sshfs-')
                    backup_command += ['file://' + target_mount_path]
                    sshfs_mount(backup['target_url'], target_mount_path)
                    # set backup name to make archive dir persistent
                    # (default name: hash of target url)
                    backup_command += ['--name', hashlib.sha1(backup['target_url'].encode('utf-8')).hexdigest()]
                else:
                    backup_command += [backup['target_url']]
                try:
                    if tab_dry:
                        print('* {}'.format(command_join(backup_command)))
                    else:
                        print('+ {}'.format(command_join(backup_command)))
                        subprocess.check_call(backup_command)
                finally:
                    if target_mount_path:
                        sshfs_unmount(target_mount_path)

            finally:
                if target_mount_path:
                    os.rmdir(target_mount_path)
                if source_mount_path:
                    sshfs_unmount(source_mount_path)

        finally:
            if source_mount_path:
                os.rmdir(source_mount_path)

def run(command, config_path, no_print_config, no_print_statistics, tab_dry):

    with open(config_path) as config_file:
        config = yaml.load(config_file.read())

    if command == 'backup':
        backup(
            config = config,
            no_print_config = no_print_config,
            no_print_statistics = no_print_statistics,
            tab_dry = tab_dry,
            )

def _init_argparser():

    import argparse
    argparser = argparse.ArgumentParser(description = None)
    argparser.add_argument(
            '-c',
            '--config',
            dest = 'config_path',
            default = '/etc/duplitab',
            )
    subparsers = argparser.add_subparsers(
            dest = 'command',
            )
    subparser_backup = subparsers.add_parser('backup')
    subparser_backup.add_argument(
            '--no-print-config',
            action = 'store_true',
            )
    subparser_backup.add_argument(
            '--no-print-statistics',
            action = 'store_true',
            )
    subparser_backup.add_argument(
            '--tab-dry',
            action = 'store_true',
            )

    return argparser

def main(argv):

    argparser = _init_argparser()
    try:
        import argcomplete
        argcomplete.autocomplete(argparser)
    except ImportError:
        pass
    args = argparser.parse_args(argv)

    run(**vars(args))

    return 0

if __name__ == "__main__":
    import sys
    sys.exit(main(sys.argv[1:]))
